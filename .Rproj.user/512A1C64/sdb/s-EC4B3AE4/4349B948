{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Intro to ggplot2\"\nauthor: \"Brad Boehmke\"\ndate: \"May 4, 2017\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, collapse = TRUE, message = FALSE, warning = FALSE)\n```\n\nBeing able to create __*visualizations*__ (graphical representations) of data is a key step in being able to communicate information and findings to others. In this module you will learn to use the __*`ggplot2`*__ library to declaratively make beautiful plots or charts of your data. Although R does provide built-in plotting functions, the `ggplot2` library implements the [Grammar of Graphics](https://www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448/ref=sr_1_fkmr0_1?ie=UTF8&qid=1493924426&sr=8-1-fkmr0&keywords=grammar+of+graphics+ggplot). This makes it particularly effective for describing how visualizations should represent data, and has turned it into the preeminent plotting library in R. Learning this library will allow you to make nearly any kind of (static) data visualization, customized to your exact specifications.\n\n<center>\n<img src=\"http://bradleyboehmke.github.io/public/images/tufte/unnamed-chunk-1-1.png\">\n</center>\n\n## tl;dr\n\nThis tutorial will provide a general introduction to the ggplot syntax.[^adapted]\n\n- Replication requirements\n- Grammar of graphics\n- Aesthetic mappings\n- Specifying geometric shapes\n- Managing scales\n- Coordinate systems\n- Facets\n- Labels & annotations\n- Additional resources on `ggplot2`\n- Other visualization libraries\n \n## Replication requirements\n\nTo reproduce the code throughout this tutorial you will need to load the `ggplot2` package. Note that `ggplot2` also comes with a number of built-in data sets. This tutorial will use the provided `mpg` data set as an example, which is a data frame that contains information about fuel economy for different cars.\n\n```{r}\nlibrary(ggplot2)\n\nmpg\n```\n\n\n## Grammar of Graphics\n\nJust as the grammar of language helps us construct meaningful sentences out of words, the [__*Grammar of Graphics*__](https://www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448/ref=sr_1_fkmr0_1?ie=UTF8&qid=1493924426&sr=8-1-fkmr0&keywords=grammar+of+graphics+ggplot) helps us to construct graphical figures out of different visual elements. This grammar gives us a way to talk about parts of a plot: all the circles, lines, arrows, and words that are combined into a diagram for visualizing data. Originally developed by Leland Wilkinson, the Grammar of Graphics was [adapted by Hadley Wickham](https://www.amazon.com/ggplot2-Elegant-Graphics-Data-Analysis/dp/331924275X/ref=dp_ob_image_bk) to describe the components of a plot, including\n\n- the **data** being plotted\n- the **geometric objects** (circles, lines, etc.) that appear on the plot\n- a set of mappings from variables in the data to the **aesthetics** (appearance) of the geometric objects\n- a **statistical transformation** used to calculate the data values used in the plot\n- a **position adjustment** for locating each geometric object on the plot\n- a **scale** (e.g., range of values) for each aesthetic mapping used\n- a **coordinate system** used to organize the geometric objects\n- the **facets** or groups of data shown in different plots\n\nWickham further organizes these components into **layers**, where each layer has a single *geometric object, statistical transformation, and position adjustment*. Following this grammar, you can think of each plot as a set of layers of images, where each image’s appearance is based on some aspect of the data set. \n\nAll together, this grammar enables us to discuss what plots look like using a standard set of vocabulary. And similar to how [`tidyr`](tidyr) and [`dplyr`](dplyr) provide efficient data transformation and manipulation, `ggplot2` provides more efficient ways to create specific visual images.\n\n## The Basics\n\nIn order to create a plot, you:\n\n1. Call the `ggplot()` function which creates a blank canvas\n2. Specify **aesthetic mappings**, which specifies how you want to map variables to visual aspects. In this case we are simply mapping the  *displ* and *hwy* variables to the x- and y-axes.\n3. You then add new layers that are geometric objects which will show up on the plot. In this case we add `geom_point` to add a layer with *points* (dot) elements as the geometric shapes to represent the data.\n\n```{r, eval=FALSE}\n# create canvas\nggplot(mpg)\n\n# variables of interest mapped\nggplot(mpg, aes(x = displ, y = hwy))\n\n# data plotted\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\n```\n\n```{r, fig.align='center', fig.width=9, fig.height=3, echo=FALSE}\n# create canvas\np1 <- ggplot(mpg) +\n  ggtitle(\"Canvas \\n\")\n\n# variables of interest mapped\np2 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  ggtitle(\"Canvas + variables mapped \\nto axes\")\n\n# data plotted\np3 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  ggtitle(\"Data plotted \\n\")\n  \ngridExtra::grid.arrange(p1, p2, p3, nrow = 1)\n```\n\nNote that when you added the `geom` layer you used the addition (`+`) operator.  As you add new layers you will always use `+` to add onto your visualization.\n\n## Aesthetic Mappings\n\nThe __*aesthetic mappings*__ take properties of the data and use them to influence visual characteristics, such as *position*, *color*, *size*, *shape*, or *transparency*. Each visual characteristic can thus encode an aspect of the data and be used to convey information.\n\nAll aesthetics for a plot are specified in the [aes()](http://ggplot2.tidyverse.org/reference/index.html#section-aesthetics) function call (later in this tutorial you will see that each `geom` layer can have its own `aes` specification). For example, we can add a mapping from the class of the cars to a *color* characteristic:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n```\n\nNote that using the `aes()` function will cause the visual channel to be based on the data specified in the argument. For example, using `aes(color = \"blue\")` won’t cause the geometry’s color to be “blue”, but will instead cause the visual channel to be mapped from the vector `c(\"blue\")` — as if we only had a single type of engine that happened to be called “blue”. If you wish to apply an aesthetic property to an entire geometry, you can set that property as an argument to the `geom` method, outside of the `aes()` call:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"blue\")\n```\n\n## Specifying Geometric Shapes\n\nBuilding on these basics, `ggplot2` can be used to build almost any kind of plot you may want. These plots are declared using functions that follow from the Grammar of Graphics.\n\nThe most obvious distinction between plots is what **geometric objects** (`geoms`) they include. `ggplot2` supports a number of different types of [`geoms`](http://ggplot2.tidyverse.org/reference/index.html#section-layer-geoms), including:\n\n- `geom_point` for drawing individual points (e.g., a scatter plot)\n- `geom_line` for drawing lines (e.g., for a line charts)\n- `geom_smooth` for drawing smoothed lines (e.g., for simple trends or approximations)\n- `geom_bar` for drawing bars (e.g., for bar charts)\n- `geom_histogram` for drawing binned values (e.g. a histogram)\n- `geom_polygon` for drawing arbitrary shapes\n- `geom_map` for drawing polygons in the shape of a map! (You can access the data to use for these maps by using the [`map_data()`](http://ggplot2.tidyverse.org/reference/map_data.html) function).\n\nEach of these geometries will leverage the aesthetic mappings supplied although the specific visual properties that the data will map to will vary. For example, you can map data to the `shape` of a `geom_point` (e.g., if they should be circles or squares), or you can map data to the `linetype` of a `geom_line` (e.g., if it is solid or dotted), but not vice versa.\n\nAlmost all `geoms` require an `x` and `y` mapping at the bare minimum.\n\n```{r, eval=FALSE}\n# Left column: x and y mapping needed!\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth()\n\n# Right column: no y mapping needed!\nggplot(data = mpg, aes(x = class)) +\n  geom_bar()  \n\nggplot(data = mpg, aes(x = hwy)) +\n  geom_histogram() \n```\n\n```{r, fig.align='center', fig.width=9, fig.height=6, echo=FALSE}\n\np1 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  ggtitle(\"x and y mapping needed!\")\n\n\np2 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth()\n\n\np3 <- ggplot(data = mpg, aes(x = class)) +\n  geom_bar() +\n  ggtitle(\"no y mapping needed!\")\n\np4 <- ggplot(data = mpg, aes(x = hwy)) +\n  geom_histogram()\n  \ngridExtra::grid.arrange(p1, p3, p2, p4, nrow = 2)\n```\n\nWhat makes this really powerful is that you can add __*multiple*__ geometries to a plot, thus allowing you to create complex graphics showing multiple aspects of your data.\n\n```{r fig.align='center', fig.width=6, fig.height=3}\n# plot with both points and smoothed line\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n```\n\nOf course the aesthetics for each `geom` can be different, so you could show multiple lines on the same plot (or with different colors, styles, etc). It’s also possible to give each `geom` a different data argument, so that you can show multiple data sets in the same plot.\n\nFor example, we can plot both points and a smoothed line for the same `x` and `y` variable but specify unique colors within each `geom`:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"blue\") +\n  geom_smooth(color = \"red\")\n```\n\nSo as you can see if we specify an aesthetic within `ggplot` it will be passed on to each `geom` that follows.  Or we can specify certain aes within each `geom`, which allows us to only show certain characteristics for that specificy layer (i.e. `geom_point`).\n\n```{r eval=FALSE}\n# color aesthetic passed to each geom layer\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n# color aesthetic specified for only the geom_point layer\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE)\n```\n\n```{r fig.align='center', fig.width=9, fig.height=3, echo=FALSE}\n# color aesthetic passed to each geom layer\np1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n# color aesthetic specified for only the geom_point layer\np2 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE)\n\ngridExtra::grid.arrange(p1, p2, nrow = 1)\n```\n\n### Statistical Transformations\n\nIf you look at the below bar chart, you’ll notice that the the y axis was defined for us as the *count* of elements that have the particular type. This count isn’t part of the data set (it’s not a column in mpg), but is instead a __*statistical transformation*__ that the `geom_bar` automatically applies to the data. In particular, it applies the `stat_count` transformation.\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(x = class)) +\n  geom_bar()\n```\n\n`ggplot2` supports many different statistical transformations. For example, the “identity” transformation will leave the data “as is”. You can specify which statistical transformation a `geom` uses by passing it as the `stat` argument.  For example, consider our data already had the count as a variable:\n\n```{r}\nclass_count <- dplyr::count(mpg, class)\nclass_count\n```\n\nWe can use `stat = \"identity\"` within `geom_bar` to plot our bar height values to this variable.  Also, note that we now include *n* for our y variable:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(class_count, aes(x = class, y = n)) +\n  geom_bar(stat = \"identity\")\n```\n\nWe can also call `stat_` functions directly to add additional layers.  For example, here we create a scatter plot of highway miles for each displacement value and then use `stat_summary` to plot the mean highway miles at each displacement value.\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(color = \"grey\") + \n  stat_summary(fun.y = \"mean\", geom = \"line\", size = 1, linetype = \"dashed\")\n```\n\n### Position Adjustments\n\nIn addition to a default statistical transformation, each `geom` also has a default __*position adjustment*__ which specifies a set of “rules” as to how different components should be positioned relative to each other. This position is noticeable in a `geom_bar` if you map a different variable to the color visual characteristic:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\n# bar chart of class, colored by drive (front, rear, 4-wheel)\nggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar()\n```\n\nThe `geom_bar` by default uses a position adjustment of `\"stack\"`, which makes each rectangle’s height proprotional to its value and stacks them on top of each other. We can use the `position` argument to specify what position adjustment rules to follow: \n\n```{r eval=FALSE}\n# position = \"dodge\": values next to each other\nggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar(position = \"dodge\")\n\n# position = \"fill\": percentage chart\nggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar(position = \"fill\")\n```\n\n```{r fig.align='center', fig.width=9, fig.height=3, echo=FALSE}\n# position = \"dodge\": values next to each other\np1 <- ggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar(position = \"dodge\") +\n  ggtitle(\"position = 'dodge'\")\n\n# position = \"fill\": percentage chart\np2 <- ggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar(position = \"fill\") +\n  ggtitle(\"position = 'fill'\")\n\ngridExtra::grid.arrange(p1, p2, nrow = 1)\n```\n\nCheck the documentation for each particular geom to learn more about its positioning adjustments.\n\n\n## Managing Scales\n\nWhenever you specify an aesthetic mapping, `ggplot` uses a particular __*scale*__ to determine the range of values that the data should map to. Thus when you specify\n\n```{r eval=FALSE}\n# color the data by engine type\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n```\n\n`ggplot` automatically adds a scale for each mapping to the plot:\n\n```{r eval=FALSE}\n# same as above, with explicit scales\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_colour_discrete()\n```\n\nEach scale can be represented by a function with the following name: `scale_`, followed by the name of the aesthetic property, followed by an `_` and the name of the scale. A `continuous` scale will handle things like numeric data (where there is a *continuous* set of numbers), whereas a `discrete` scale will handle things like colors (since there is a small list of *distinct* colors).\n\nWhile the default scales will work fine, it is possible to explicitly add different scales to replace the defaults. For example, you can use a scale to change the direction of an axis:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\n# milage relationship, ordered in reverse\nggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point() +\n  scale_x_reverse() +\n  scale_y_reverse()\n```\n\nSimilarly, you can use `scale_x_log10()` and `scale_x_sqrt()` to transform your scale. You can also use `scales` to format your axes:\n\n```{r fig.align='center', fig.width=6, fig.height=3}\nggplot(mpg, aes(x = class, fill = drv)) + \n  geom_bar(position = \"fill\") +\n  scale_y_continuous(breaks = seq(0, 1, by = .2), labels = scales::percent)\n```\n\n\nA common parameter to change is which set of colors to use in a plot. While you can use the default coloring, a more common option is to leverage the pre-defined palettes from [colorbrewer.org](http://colorbrewer2.org/). These color sets have been carefully designed to look good and to be viewable to people with certain forms of color blindness. We can leverage color brewer palletes by specifying the `scale_color_brewer()` function, passing the pallete as an argument.\n\n```{r eval=FALSE}\n# default color brewer\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  scale_color_brewer()\n\n# specifying color palette\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set3\")\n```\n\n```{r fig.align='center', fig.width=9, fig.height=3, echo=FALSE}\n# default color brewer\np1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  scale_color_brewer()\n\n# specifying color palette\np2 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  scale_color_brewer(palette = \"Set3\")\n\ngridExtra::grid.arrange(p1, p2, nrow = 1)\n```\n\nNote that you can get the palette name from the [colorbrewer website](http://colorbrewer2.org/) by looking at the scheme query parameter in the URL. Or see the diagram [here](https://bl.ocks.org/mbostock/5577023) and hover the mouse over each palette for the name.\n\nYou can also specify *continuous* color values by using a [gradient](http://ggplot2.tidyverse.org/reference/scale_gradient.html) scale, or [manually](http://ggplot2.tidyverse.org/reference/scale_manual.html) specify the colors you want to use as a named vector.\n\n## Coordinate Systems\n\nThe next term from the Grammar of Graphics that can be specified is the __*coordinate system*__. As with scales, coordinate systems are specified with functions that all start with `coord_` and are added as a layer. There are a number of different possible coordinate systems to use, including:\n\n- `coord_cartesian` the default [cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system), where you specify x and y values (e.g. allows you to zoom in or out).\n- `coord_flip` a cartesian system with the x and y flipped\n- `coord_fixed` a cartesian system with a “fixed” aspect ratio (e.g., 1.78 for a “widescreen” plot)\n- `coord_polar` a plot using [polar coordinates](https://en.wikipedia.org/wiki/Polar_coordinate_system)\n- `coord_quickmap` a coordinate system that approximates a good aspect ratio for maps. See documentation for more details.\n\n```{r, eval=FALSE}\n# zoom in with coord_cartesian\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  coord_cartesian(xlim = c(0, 5))\n\n# flip x and y axis with coord_flip\nggplot(mpg, aes(x = class)) +\n  geom_bar() +\n  coord_flip()\n```\n\n```{r fig.align='center', fig.width=9, fig.height=3, echo=FALSE}\n# zoom in with coord_cartesian\np1 <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  coord_cartesian(xlim = c(0, 5))\n\n# flip x and y axis with coord_flip\np2 <- ggplot(mpg, aes(x = class)) +\n  geom_bar() +\n  coord_flip()\n\ngridExtra::grid.arrange(p1, p2, nrow = 1)\n```\n\n\n## Facets\n\n__*Facets*__ are ways of grouping a data plot into multiple different pieces (subplots). This allows you to view a separate plot for each value in a categorical variable. You can construct a plot with multiple facets by using the `facet_wrap()` function. This will produce a “row” of subplots, one for each categorical variable (the number of rows can be specified with an additional argument):\n\n```{r fig.align='center', fig.width=9, fig.height=3}\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_grid(~ class)\n```\n\nYou can also `facet_grid` to facet your data by more than one categorical variable. Note that we use a tilde (`~`) in our `facet` functions.  With `facet_grid` the variable to the left of the tilde will be represented in the rows and the variable to the right will be represented across the columns. \n\n```{r fig.align='center', fig.width=9, fig.height=5}\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_grid(year ~ cyl)\n```\n\n## Labels & Annotations\n\nTextual labels and annotations (on the plot, axes, geometry, and legend) are an important part of making a plot understandable and communicating information. Although not an explicit part of the Grammar of Graphics (the would be considered a form of geometry), `ggplot` makes it easy to add such annotations.\n\nYou can add titles and axis labels to a chart using the `labs()` function (not `labels`, which is a different R function!):\n\n```{r fig.align='center', fig.width=7, fig.height=4}\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point() +\n  labs(title = \"Fuel Efficiency by Engine Power\",\n       subtitle = \"Fuel economy data from 1999 and 2008 for 38 popular models of cars\",\n       x = \"Engine power (litres displacement)\",\n       y = \"Fuel Efficiency (miles per gallon)\",\n       color = \"Car Type\")\n```\n\nIt is also possible to add labels into the plot itself (e.g., to label each point or line) by adding a new `geom_text` or `geom_label` to the plot; effectively, you’re plotting an extra set of data which happen to be the variable names:\n\n```{r fig.align='center', fig.width=7, fig.height=3}\nlibrary(dplyr)\n\n# a data table of each car that has best efficiency of its type\nbest_in_class <- mpg %>%\n  group_by(class) %>%\n  filter(row_number(desc(hwy)) == 1)\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) +\n  geom_label(data = best_in_class, aes(label = model), alpha = 0.5)\n```\n\nHowever, note that two labels overlap one-another in the top left part of the plot.  We can use the `geom_text_repel` function from the  [`ggrepel`](https://github.com/slowkow/ggrepel) package to help position labels.\n\n```{r fig.align='center', fig.width=7, fig.height=3}\nlibrary(ggrepel)\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) +\n  geom_text_repel(data = best_in_class, aes(label = model))\n```\n\n## Additional Resources on `ggplot2`\n\nThis gets you started with `ggplot2`; however, this a lot more to learn.  Future [tutorials](ggplot) illustrate how to convert many common forms of visualization (i.e. histograms, bar charts, line charts) and turn them into advanced, publication worthy graphics.  Furthermore, the following resources provide additional avenues to learn more:\n\n- [gglot2 Documentation](http://ggplot2.tidyverse.org/) (particularly the [function reference](http://ggplot2.tidyverse.org/reference/index.html))\n- [ggplot2 Cheat Sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf) (see also [here](http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/))\n- [Data Visualization portion of R for Data Science Book](http://r4ds.had.co.nz/data-visualisation.html)\n- [A Layered Grammar of Graphics (Wickham)](http://vita.had.co.nz/papers/layered-grammar.pdf)\n\n## Other Visualization Libraries\n\n`ggplot2` is easily the most popular library for producing data visualizations in R. That said, ggplot2 is used to produce __static__ visualizations: unchanging “pictures” of plots. Static plots are great for for __explanatory visualizations__: visualizations that are used to communicate some information—or more commonly, an argument about that information. All of the above visualizations have been ways for us to explain and demonstrate an argument about the data (e.g., the relationship between car engines and fuel efficiency).\n\nData visualizations can also be highly effective for __exploratory analysis__, in which the visualization is used as a way to ask and answer questions about the data (rather than to convey an answer or argument). While it is perfectly feasible to do such exploration on a static visualization, many explorations can be better served with __interactive visualizations__ in which the user can select and change the view and presentation of that data in order to understand it.\n\nWhile `ggplot2` does not directly support interactive visualizations, there are a number of additional R libraries that provide this functionality, including:\n\n- [`ggvis`](http://ggvis.rstudio.com/) is a library that uses the Grammar of Graphics (similar to ggplot), but for interactive visualizations. \n- [`plotly`](https://plot.ly/r/) is a open-source library for developing interactive visualizations. It provides a number of “standard” interactions (pop-up labels, drag to pan, select to zoom, etc) automatically. Moreover, it is possible to take a `ggplot2` plot and [wrap](https://plot.ly/ggplot2/) it in Plotly in order to make it interactive. Plotly has many examples to learn from, though a less effective set of documentation.\n- [`htmlwidgets`](http://www.htmlwidgets.org/) provides a way to utilize a number of JavaScript interactive visualization libraries. JavaScript is the programming language used to create interactive websites (HTML files), and so is highly specialized for creating interactive experiences.\n\n\n\n\n[^adapted]: Examples in this module adapted from [*R for Data Science*](http://r4ds.had.co.nz/)\n",
    "created" : 1493924160327.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3084573272",
    "id" : "4349B948",
    "lastKnownWriteTime" : 1493933657,
    "last_content_update" : 1493933717015,
    "path" : "~/Desktop/Projects/Visualization-Tutorials/ggplot2-intro.Rmd",
    "project_path" : "ggplot2-intro.Rmd",
    "properties" : {
        "last_setup_crc32" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}